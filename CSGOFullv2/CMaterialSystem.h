#pragma once

#include "IMaterial.h"
#include "Interfaces.h"
#define VirtualFn( cast )typedef cast( __thiscall* OriginalFn )
// These are given to FindMaterial to reference the texture groups that show up on the 
#define TEXTURE_GROUP_LIGHTMAP						"Lightmaps"
#define TEXTURE_GROUP_WORLD							"World textures"
#define TEXTURE_GROUP_MODEL							"Model textures"
#define TEXTURE_GROUP_VGUI							"VGUI textures"
#define TEXTURE_GROUP_PARTICLE						"Particle textures"
#define TEXTURE_GROUP_DECAL							"Decal textures"
#define TEXTURE_GROUP_SKYBOX						"SkyBox textures"
#define TEXTURE_GROUP_CLIENT_EFFECTS				"ClientEffect textures"
#define TEXTURE_GROUP_OTHER							"Other textures"
#define TEXTURE_GROUP_PRECACHED						"Precached"				// TODO: assign texture groups to the precached materials
#define TEXTURE_GROUP_CUBE_MAP						"CubeMap textures"
#define TEXTURE_GROUP_RENDER_TARGET					"RenderTargets"
#define TEXTURE_GROUP_UNACCOUNTED					"Unaccounted textures"	// Textures that weren't assigned a texture group.
//#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER		"Static Vertex"
#define TEXTURE_GROUP_STATIC_INDEX_BUFFER			"Static Indices"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_DISP		"Displacement Verts"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_COLOR	"Lighting Verts"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_WORLD	"World Verts"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_MODELS	"Model Verts"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_OTHER	"Other Verts"
#define TEXTURE_GROUP_DYNAMIC_INDEX_BUFFER			"Dynamic Indices"
#define TEXTURE_GROUP_DYNAMIC_VERTEX_BUFFER			"Dynamic Verts"
#define TEXTURE_GROUP_DEPTH_BUFFER					"DepthBuffer"
#define TEXTURE_GROUP_VIEW_MODEL					"ViewModel"
#define TEXTURE_GROUP_PIXEL_SHADERS					"Pixel Shaders"
#define TEXTURE_GROUP_VERTEX_SHADERS				"Vertex Shaders"
#define TEXTURE_GROUP_RENDER_TARGET_SURFACE			"RenderTarget Surfaces"
#define TEXTURE_GROUP_MORPH_TARGETS					"Morph Targets"

enum RenderTargetSizeMode_t
{
	RT_SIZE_NO_CHANGE = 0,            // Only allowed for render targets that don't want a depth buffer
									  // (because if they have a depth buffer, the render target must be less than or equal to the size of the framebuffer).
									  RT_SIZE_DEFAULT = 1,                // Don't play with the specified width and height other than making sure it fits in the framebuffer.
									  RT_SIZE_PICMIP = 2,                // Apply picmip to the render target's width and height.
									  RT_SIZE_HDR = 3,                    // frame_buffer_width / 4
									  RT_SIZE_FULL_FRAME_BUFFER = 4,    // Same size as frame buffer, or next lower power of 2 if we can't do that.
									  RT_SIZE_OFFSCREEN = 5,            // Target of specified size, don't mess with dimensions
									  RT_SIZE_FULL_FRAME_BUFFER_ROUNDED_UP = 6 // Same size as the frame buffer, rounded up if necessary for systems that can't do non-power of two textures.
};

enum MaterialRenderTargetDepth_t
{
	MATERIAL_RT_DEPTH_SHARED = 0x0,
	MATERIAL_RT_DEPTH_SEPARATE = 0x1,
	MATERIAL_RT_DEPTH_NONE = 0x2,
	MATERIAL_RT_DEPTH_ONLY = 0x3,
};

enum TextureFlags
{
	// flags from the *.txt config file
	TEXTUREFLAGS_POINTSAMPLE = 0x00000001,
	TEXTUREFLAGS_TRILINEAR = 0x00000002,
	TEXTUREFLAGS_CLAMPS = 0x00000004,
	TEXTUREFLAGS_CLAMPT = 0x00000008,
	TEXTUREFLAGS_ANISOTROPIC = 0x00000010,
	TEXTUREFLAGS_HINT_DXT5 = 0x00000020,
	TEXTUREFLAGS_SRGB = 0x00000040,
	TEXTUREFLAGS_NORMAL = 0x00000080,
	TEXTUREFLAGS_NOMIP = 0x00000100,
	TEXTUREFLAGS_NOLOD = 0x00000200,
	TEXTUREFLAGS_ALL_MIPS = 0x00000400,
	TEXTUREFLAGS_PROCEDURAL = 0x00000800,

	// These are automatically generated by vtex from the texture data.
	TEXTUREFLAGS_ONEBITALPHA = 0x00001000,
	TEXTUREFLAGS_EIGHTBITALPHA = 0x00002000,

	// newer flags from the *.txt config file
	TEXTUREFLAGS_ENVMAP = 0x00004000,
	TEXTUREFLAGS_RENDERTARGET = 0x00008000,
	TEXTUREFLAGS_DEPTHRENDERTARGET = 0x00010000,
	TEXTUREFLAGS_NODEBUGOVERRIDE = 0x00020000,
	TEXTUREFLAGS_SINGLECOPY = 0x00040000,

	TEXTUREFLAGS_UNUSED_00080000 = 0x00080000,
	TEXTUREFLAGS_UNUSED_00100000 = 0x00100000,
	TEXTUREFLAGS_UNUSED_00200000 = 0x00200000,
	TEXTUREFLAGS_UNUSED_00400000 = 0x00400000,

	TEXTUREFLAGS_NODEPTHBUFFER = 0x00800000,

	TEXTUREFLAGS_UNUSED_01000000 = 0x01000000,

	TEXTUREFLAGS_CLAMPU = 0x02000000,

	TEXTUREFLAGS_VERTEXTEXTURE = 0x04000000,                    // Useable as a vertex texture

	TEXTUREFLAGS_SSBUMP = 0x08000000,

	TEXTUREFLAGS_UNUSED_10000000 = 0x10000000,

	// Clamp to border color on all texture coordinates
	TEXTUREFLAGS_BORDER = 0x20000000,

	TEXTUREFLAGS_UNUSED_40000000 = 0x40000000,
	TEXTUREFLAGS_UNUSED_80000000 = 0x80000000,
};

enum RenderViewInfo_t : char
{
	RENDERVIEW_UNSPECIFIED = 0,
	RENDERVIEW_DRAWVIEWMODEL = (1 << 0),
	RENDERVIEW_DRAWHUD = (1 << 1),
	RENDERVIEW_SUPPRESSMONITORRENDERING = (1 << 2),
};

enum ClearFlags_t : int
{
	VIEW_CLEAR_COLOR = 0x1,
	VIEW_CLEAR_DEPTH = 0x2,
	VIEW_CLEAR_FULL_TARGET = 0x4,
	VIEW_NO_DRAW = 0x8,
	VIEW_CLEAR_OBEY_STENCIL = 0x10, // Draws a quad allowing stencil test to clear through portals
	VIEW_CLEAR_STENCIL = 0x20,
};



// TODO : Complete Materiel System 
class CMaterialSystem
{
public:
		IMaterial* FindMaterial(char const* pMaterialName, const char* pTextureGroupName = TEXTURE_GROUP_MODEL, bool complain = true, const char* pComplainPrefix = nullptr)
		{
			typedef IMaterial*(__thiscall * OriginalFn)(void*, char const*, const char*, bool, const char*);
			return GetVFunc< OriginalFn >(this, 84)(this, pMaterialName, pTextureGroupName, complain, pComplainPrefix);
		}

		IMaterial* CreateMaterial(const char* name, KeyValues* keyValues)
		{
			typedef IMaterial*(__thiscall * CreateMaterial_t)(void*, const char*, KeyValues*);
			return GetVFunc< CreateMaterial_t >(this, 83)(this, name, keyValues);
		}

		MaterialHandle_t FirstMaterial()
		{
			VirtualFn(MaterialHandle_t)(PVOID);
			return GetVFunc< OriginalFn >(this, 86)(this);
		}
		MaterialHandle_t NextMaterial(MaterialHandle_t h)
		{
			VirtualFn(MaterialHandle_t)(PVOID, MaterialHandle_t);
			return GetVFunc< OriginalFn >(this, 87)(this, h);
		}
		MaterialHandle_t InvalidMaterial()
		{
			VirtualFn(MaterialHandle_t)(PVOID);
			return GetVFunc< OriginalFn >(this, 88)(this);
		}
		IMaterial* GetMaterial(MaterialHandle_t h)
		{
			VirtualFn(IMaterial*)(PVOID, MaterialHandle_t);
			return GetVFunc< OriginalFn >(this, 89)(this, h);
		}

		ImageFormat GetBackBufferFormat()
		{
			typedef ImageFormat(__thiscall* GetBackBufferFormat_t)(void*);
			return GetVFunc<GetBackBufferFormat_t>(this, 36)(this);
		}

		void BeginRenderTargetAllocation()
		{
			typedef void(__thiscall* BeginRenderTargetAllocation_t)(void*);
			GetVFunc<BeginRenderTargetAllocation_t>(this, 94)(this);
		}

		void EndRenderTargetAllocation()
		{
			typedef void(__thiscall* EndRenderTargetAllocation_t)(void*);
			GetVFunc<EndRenderTargetAllocation_t>(this, 95)(this);
		}

		ITexture* CreateNamedRenderTargetTextureEx(
			const char* name, int w, int h, RenderTargetSizeMode_t sizeMode,
			ImageFormat format, MaterialRenderTargetDepth_t depth,
			unsigned int textureFlags, unsigned int renderTargetFlags
		)
		{
			typedef ITexture*(__thiscall* CreateNamedRenderTargetTextureEx_t)(void*, const char*, int, int, RenderTargetSizeMode_t,
				ImageFormat, MaterialRenderTargetDepth_t, unsigned int, unsigned int);
			return GetVFunc<CreateNamedRenderTargetTextureEx_t>(this, 97)(this, name, w, h, sizeMode, format, depth, textureFlags, renderTargetFlags);
		}

		IMatRenderContext* GetRenderContext()
		{
			VirtualFn(IMatRenderContext*)(void*);
			return GetVFunc<OriginalFn>(this, 115)(this);
		}

		void ForceBeginRenderTargetAllocation() {
			bool oldState = *(bool*)((uint32_t)this + 0x2C68); // m_bGameStarted
			*(bool*)((uint32_t)this + 0x2C68) = false;         // Fooling the game that loading is not finished yet
			BeginRenderTargetAllocation();
			*(bool*)((uint32_t)this + 0x2C68) = oldState;
		}

		void ForceEndRenderTargetAllocation() {
			bool oldState = *(bool*)((uint32_t)this + 0x2C68);
			*(bool*)((uint32_t)this + 0x2C68) = false;
			EndRenderTargetAllocation();
			*(bool*)((uint32_t)this + 0x2C68) = oldState;
		}

		ITexture* CreateFullFrameRenderTarget(const char* name) {
			return CreateNamedRenderTargetTextureEx(
				name, 1, 1, RT_SIZE_FULL_FRAME_BUFFER, GetBackBufferFormat(),
				MATERIAL_RT_DEPTH_SHARED, TEXTUREFLAGS_CLAMPS | TEXTUREFLAGS_CLAMPT,
				1 // CREATERENDERTARGETFLAGS_HDR
			);
		}

};